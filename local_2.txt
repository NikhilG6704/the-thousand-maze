{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<style>\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n    font-family: Arial, sans-serif;\n}\n\n\n/* Control Panel */\n#controls, #gameControls {\n    display: flex;\n    gap: 15px;\n    margin-bottom: 20px;\n    align-items: center;\n    flex-wrap: wrap;\n}\n\n#controls label {\n    margin-right: 5px;\n    font-size: 16px;\n}\n\ninput[type=\"number\"] {\n    width: 60px;\n    padding: 5px;\n    font-size: 16px;\n    border-radius: 5px;\n    border: 1px solid #ddd;\n    background-color: #444;\n    color: #fff;\n    text-align: center;\n}\n\n/* Set Maze Size Button */\n#setSizeBtn {\n    background-color: #007bff;\n    color: #fff;\n    padding: 10px 20px;\n    border: none;\n    border-radius: 5px;\n    cursor: pointer;\n    font-size: 16px;\n    transition: background-color 0.3s;\n}\n\n#setSizeBtn:hover {\n    background-color: #0056b3;\n}\n\n/* Start and Pause Buttons */\n#startBtn {\n    background-color: #28a745;\n}\n\n#pauseBtn {\n    background-color: #ff5722;\n}\n\nbutton {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 5px;\n    cursor: pointer;\n    font-size: 16px;\n    transition: background-color 0.3s;\n    color: #fff;\n}\n\nbutton:hover {\n    background-color: #555;\n}\n\n#timer {\n    font-size: 18px;\n    font-weight: bold;\n}\n\n/* Canvas */\n#mazeCanvas {\n    border: 2px solid #f0a500;\n    background-color: #222;\n    margin-top: 20px;\n}\n\n/* Responsiveness */\n@media (max-width: 600px) {\n    body {\n        padding: 10px;\n    }\n\n    #controls, #gameControls {\n        flex-direction: column;\n        align-items: flex-start;\n    }\n\n    button {\n        width: 100%;\n        text-align: center;\n    }\n\n    #timer {\n        margin-top: 10px;\n        text-align: center;\n    }\n}\n</start?",
      "status": "",
      "output": "<style>\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n    font-family: Arial, sans-serif;\n}\n\n\n/* Control Panel */\n#controls, #gameControls {\n    display: flex;\n    gap: 15px;\n    margin-bottom: 20px;\n    align-items: center;\n    flex-wrap: wrap;\n}\n\n#controls label {\n    margin-right: 5px;\n    font-size: 16px;\n}\n\ninput[type=\"number\"] {\n    width: 60px;\n    padding: 5px;\n    font-size: 16px;\n    border-radius: 5px;\n    border: 1px solid #ddd;\n    background-color: #444;\n    color: #fff;\n    text-align: center;\n}\n\n/* Set Maze Size Button */\n#setSizeBtn {\n    background-color: #007bff;\n    color: #fff;\n    padding: 10px 20px;\n    border: none;\n    border-radius: 5px;\n    cursor: pointer;\n    font-size: 16px;\n    transition: background-color 0.3s;\n}\n\n#setSizeBtn:hover {\n    background-color: #0056b3;\n}\n\n/* Start and Pause Buttons */\n#startBtn {\n    background-color: #28a745;\n}\n\n#pauseBtn {\n    background-color: #ff5722;\n}\n\nbutton {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 5px;\n    cursor: pointer;\n    font-size: 16px;\n    transition: background-color 0.3s;\n    color: #fff;\n}\n\nbutton:hover {\n    background-color: #555;\n}\n\n#timer {\n    font-size: 18px;\n    font-weight: bold;\n}\n\n/* Canvas */\n#mazeCanvas {\n    border: 2px solid #f0a500;\n    background-color: #222;\n    margin-top: 20px;\n}\n\n/* Responsiveness */\n@media (max-width: 600px) {\n    body {\n        padding: 10px;\n    }\n\n    #controls, #gameControls {\n        flex-direction: column;\n        align-items: flex-start;\n    }\n\n    button {\n        width: 100%;\n        text-align: center;\n    }\n\n    #timer {\n        margin-top: 10px;\n        text-align: center;\n    }\n}\n</start?</style>",
      "type": "html"
    },
    {
      "code": "<div id=\"controls\">\n        <div>\n            <label for=\"rowsInput\">Rows:</label>\n            <input type=\"number\" id=\"rowsInput\" value=\"20\" min=\"5\" max=\"50\">\n        </div>\n        <div>\n            <label for=\"colsInput\">Columns:</label>\n            <input type=\"number\" id=\"colsInput\" value=\"20\" min=\"5\" max=\"50\">\n        </div>\n        <button id=\"setSizeBtn\">Set Maze Size</button>\n    </div>\n\n    <div id=\"gameControls\">\n        <button id=\"startBtn\">Start</button>\n        <button id=\"pauseBtn\" style=\"display: none;\">Pause</button>\n        <div id=\"timer\">Time Remaining: 60s</div>\n    </div>\n\n    <canvas id=\"mazeCanvas\"></canvas>\n\n    <script src=\"script.js\"></script>",
      "status": "",
      "output": "<div id=\"controls\">\n        <div>\n            <label for=\"rowsInput\">Rows:</label>\n            <input type=\"number\" id=\"rowsInput\" value=\"20\" min=\"5\" max=\"50\">\n        </div>\n        <div>\n            <label for=\"colsInput\">Columns:</label>\n            <input type=\"number\" id=\"colsInput\" value=\"20\" min=\"5\" max=\"50\">\n        </div>\n        <button id=\"setSizeBtn\">Set Maze Size</button>\n    </div>\n\n    <div id=\"gameControls\">\n        <button id=\"startBtn\">Start</button>\n        <button id=\"pauseBtn\" style=\"display: none;\">Pause</button>\n        <div id=\"timer\">Time Remaining: 60s</div>\n    </div>\n\n    <canvas id=\"mazeCanvas\"></canvas>\n\n    <script src=\"script.js\"></script>",
      "type": "html"
    },
    {
      "code": "document.addEventListener('DOMContentLoaded', () => {\n    const canvas = document.getElementById('mazeCanvas');\n    const ctx = canvas.getContext('2d');\n    const timerDisplay = document.getElementById('timer');\n    const startBtn = document.getElementById('startBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const setSizeBtn = document.getElementById('setSizeBtn');\n    const rowsInput = document.getElementById('rowsInput');\n    const colsInput = document.getElementById('colsInput');\n\n    let cellSize = 25;\n    let rows = 20;\n    let cols = 20;\n    canvas.width = cols * cellSize;\n    canvas.height = rows * cellSize;\n\n    let grid = [];\n    const player = {\n        row: 0,\n        col: 0,\n        size: cellSize / 2,\n        color: '#0095DD',\n        targetRow: 0,\n        targetCol: 0,\n        dx: 0,\n        dy: 0,\n        direction: 'up' // Initial direction\n    };\n    let goal = { row: 0, col: 0, size: cellSize / 2, color: '#28A745' };\n    const path = [];\n    let stack = [];\n    let timeRemaining = calculateTime();\n    let timerInterval;\n    let gameStarted = false;\n    let gamePaused = false;\n    let isMoving = false;\n\n    // Initialize the maze grid\n    function initializeGrid() {\n        grid = Array.from({ length: rows }, (_, row) => \n            Array.from({ length: cols }, (_, col) => ({\n                row, col, visited: false, walls: [true, true, true, true] // Top, Right, Bottom, Left\n            }))\n        );\n    }\n\n    // Generate maze\n    function generateMaze() {\n        initializeGrid();\n        stack.length = 0;\n        path.length = 0;\n        const startCell = grid[0][0];\n        stack.push(startCell);\n        startCell.visited = true;\n\n        while (stack.length > 0) {\n            const nextCell = getUnvisitedNeighbor(stack[stack.length - 1]);\n            if (nextCell) {\n                nextCell.visited = true;\n                removeWalls(stack[stack.length - 1], nextCell);\n                stack.push(nextCell);\n            } else {\n                stack.pop();\n            }\n        }\n        setRandomGoal(); // Set random goal after maze generation\n        drawMaze();\n    }\n\n    // Set a random goal within the grid\n    function setRandomGoal() {\n        let randomRow, randomCol;\n        do {\n            randomRow = Math.floor(Math.random() * rows);\n            randomCol = Math.floor(Math.random() * cols);\n        } while (randomRow === player.row && randomCol === player.col); // Ensure goal is not at the player's starting position\n\n        goal.row = randomRow;\n        goal.col = randomCol;\n    }\n\n    // Maze grid creation and drawing\n    function drawMaze() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        grid.forEach(row => row.forEach(cell => drawCell(cell)));\n        drawPath();\n        drawPlayerAndGoal();\n    }\n\n    // Draw individual cell walls\n    function drawCell(cell) {\n        const x = cell.col * cellSize;\n        const y = cell.row * cellSize;\n\n        ctx.strokeStyle = '#f0a500';\n        ctx.lineWidth = 2;\n\n        if (cell.walls[0]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); ctx.stroke(); } // Top\n        if (cell.walls[1]) { ctx.beginPath(); ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); } // Right\n        if (cell.walls[2]) { ctx.beginPath(); ctx.moveTo(x + cellSize, y + cellSize); ctx.lineTo(x, y + cellSize); ctx.stroke(); } // Bottom\n        if (cell.walls[3]) { ctx.beginPath(); ctx.moveTo(x, y + cellSize); ctx.lineTo(x, y); ctx.stroke(); } // Left\n    }\n\n    // Draw path taken by player\n    function drawPath() {\n        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n\n        if (path.length > 0) {\n            const startCell = path[0];\n            ctx.moveTo(startCell.col * cellSize + cellSize / 2, startCell.row * cellSize + cellSize / 2);\n        }\n\n        path.forEach(cell => {\n            ctx.lineTo(cell.col * cellSize + cellSize / 2, cell.row * cellSize + cellSize / 2);\n        });\n\n        ctx.stroke();\n    }\n\n    // Draw player and goal\n    function drawPlayerAndGoal() {\n        // Draw the goal\n        ctx.fillStyle = goal.color;\n        ctx.fillRect(goal.col * cellSize + cellSize / 4, goal.row * cellSize + cellSize / 4, goal.size, goal.size);\n    \n        // Draw the player as an arrow based on direction\n        const centerX = player.col * cellSize + cellSize / 2;\n        const centerY = player.row * cellSize + cellSize / 2;\n        const arrowSize = player.size;\n    \n        ctx.fillStyle = player.color;\n        ctx.beginPath();\n    \n        switch (player.direction) {\n            case 'up':\n                ctx.moveTo(centerX, centerY - arrowSize); // Arrow tip\n                ctx.lineTo(centerX - arrowSize / 2, centerY + arrowSize / 2); // Bottom left\n                ctx.lineTo(centerX + arrowSize / 2, centerY + arrowSize / 2); // Bottom right\n                break;\n            case 'right':\n                ctx.moveTo(centerX + arrowSize, centerY); // Arrow tip\n                ctx.lineTo(centerX - arrowSize / 2, centerY - arrowSize / 2); // Top left\n                ctx.lineTo(centerX - arrowSize / 2, centerY + arrowSize / 2); // Bottom left\n                break;\n            case 'down':\n                ctx.moveTo(centerX, centerY + arrowSize); // Arrow tip\n                ctx.lineTo(centerX - arrowSize / 2, centerY - arrowSize / 2); // Top left\n                ctx.lineTo(centerX + arrowSize / 2, centerY - arrowSize / 2); // Top right\n                break;\n            case 'left':\n                ctx.moveTo(centerX - arrowSize, centerY); // Arrow tip\n                ctx.lineTo(centerX + arrowSize / 2, centerY - arrowSize / 2); // Top right\n                ctx.lineTo(centerX + arrowSize / 2, centerY + arrowSize / 2); // Bottom right\n                break;\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    // Function to get unvisited neighbors of a given cell\n    function getUnvisitedNeighbor(cell) {\n        const { row, col } = cell;\n        const neighbors = [];\n\n        if (row > 0 && !grid[row - 1][col].visited) neighbors.push(grid[row - 1][col]);\n        if (col < cols - 1 && !grid[row][col + 1].visited) neighbors.push(grid[row][col + 1]);\n        if (row < rows - 1 && !grid[row + 1][col].visited) neighbors.push(grid[row + 1][col]);\n        if (col > 0 && !grid[row][col - 1].visited) neighbors.push(grid[row][col - 1]);\n\n        return neighbors.length > 0 ? neighbors[Math.floor(Math.random() * neighbors.length)] : null;\n    }\n\n    // Function to remove walls between adjacent cells\n    function removeWalls(cell1, cell2) {\n        const dx = cell1.col - cell2.col;\n        const dy = cell1.row - cell2.row;\n\n        if (dx === 1) { cell1.walls[3] = false; cell2.walls[1] = false; }\n        if (dx === -1) { cell1.walls[1] = false; cell2.walls[3] = false; }\n        if (dy === 1) { cell1.walls[0] = false; cell2.walls[2] = false; }\n        if (dy === -1) { cell1.walls[2] = false; cell2.walls[0] = false; }\n    }\n\n    // Function to calculate time based on maze size, capped at 100 seconds\n    function calculateTime() {\n        return Math.min(Math.max((rows * cols) / 2, 30), 100); // Cap at 100 seconds\n    }\n\n    // Start the game\n    // Start the game\nfunction startGame() {\n    if (!gameStarted) {\n        gameStarted = true;\n        gamePaused = false;\n        timerDisplay.innerText = `Time Remaining: ${timeRemaining}s`;\n        canvas.style.display = 'block';\n        startBtn.style.display = 'none';\n        pauseBtn.style.display = 'inline';\n\n        // Start the timer only when the game starts\n        timerInterval = setInterval(updateTimer, 1000);\n        generateMaze(); // Generate the maze when the game starts\n    }\n}\n\n\n    // Pause the game\n    function pauseGame() {\n        gamePaused = true;\n        clearInterval(timerInterval);\n        pauseBtn.innerText = 'Resume';\n    }\n\n    // Resume the game\n    function resumeGame() {\n        gamePaused = false;\n        timerInterval = setInterval(updateTimer, 1000);\n        pauseBtn.innerText = 'Pause';\n    }\n\n    // Update the timer\n    function updateTimer() {\n        if (timeRemaining <= 0) {\n            clearInterval(timerInterval);\n            alert(\"⏳ Time's up! Try again.\");\n            resetGame();\n        } else {\n            timeRemaining--;\n            timerDisplay.innerText = `Time Remaining: ${timeRemaining}s`;\n        }\n    }\n\n    // Reset the game\n    function resetGame() {\n        gameStarted = false;\n        player.row = 0;\n        player.col = 0;\n        player.targetRow = 0;\n        player.targetCol = 0;\n        path.length = 0;\n        timeRemaining = calculateTime();\n        timerDisplay.innerText = `Time Remaining: ${timeRemaining}s`;\n        canvas.style.display = 'none';\n        startBtn.style.display = 'inline';\n        pauseBtn.style.display = 'none';\n        generateMaze();\n    }\n\n    // Function to move the player\n    function movePlayer(dx, dy) {\n        if (isMoving || gamePaused || !gameStarted) return;\n    \n        const targetRow = player.row + dy;\n        const targetCol = player.col + dx;\n    \n        if (targetRow >= 0 && targetRow < rows && targetCol >= 0 && targetCol < cols) {\n            const currentCell = grid[player.row][player.col];\n            const targetCell = grid[targetRow][targetCol];\n    \n            // Check for walls and set direction\n            if (dx === 0 && dy === -1 && !currentCell.walls[0]) {\n                player.targetRow = targetRow;\n                player.targetCol = targetCol;\n                player.direction = 'up';\n            } else if (dx === 1 && dy === 0 && !currentCell.walls[1]) {\n                player.targetRow = targetRow;\n                player.targetCol = targetCol;\n                player.direction = 'right';\n            } else if (dx === 0 && dy === 1 && !currentCell.walls[2]) {\n                player.targetRow = targetRow;\n                player.targetCol = targetCol;\n                player.direction = 'down';\n            } else if (dx === -1 && dy === 0 && !currentCell.walls[3]) {\n                player.targetRow = targetRow;\n                player.targetCol = targetCol;\n                player.direction = 'left';\n            } else {\n                return; // Blocked by wall\n            }\n    \n            // Add current position to path\n            path.push({ row: player.row, col: player.col });\n    \n            isMoving = true;\n            animateMovement();\n        }\n    }\n\n    // Function to animate player movement\n    function animateMovement() {\n        const speed = 0.1; // Movement speed\n        const rowDiff = player.targetRow - player.row;\n        const colDiff = player.targetCol - player.col;\n\n        player.row += rowDiff * speed;\n        player.col += colDiff * speed;\n\n        if (Math.abs(player.row - player.targetRow) <= 0.5 && Math.abs(player.col - player.targetCol) <= 0.5) {\n            player.row = player.targetRow;\n            player.col = player.targetCol;\n            isMoving = false;\n            path.push({ row: player.row, col: player.col });\n            checkGoal();\n        } else {\n            requestAnimationFrame(animateMovement);\n        }\n\n        drawMaze();\n    }\n\n    // Check if player reached the goal\n    function checkGoal() {\n        if (player.row === goal.row && player.col === goal.col) {\n            alert('🎉 You reached the goal! Congratulations!');\n            resetGame();\n        }\n    }\n\n    // Event listeners for player movement\n    document.addEventListener('keydown', (event) => {\n        if (!gameStarted || gamePaused) return;\n\n        switch (event.key) {\n            case 'W': movePlayer(0, -1); break;\n            case 'w': movePlayer(0, -1); break;\n            case 'D': movePlayer(1, 0); break;\n            case 'd': movePlayer(1, 0); break;\n            case 'S': movePlayer(0, 1); break;\n            case 's': movePlayer(0, 1); break;\n            case 'A': movePlayer(-1, 0); break;\n            case 'a': movePlayer(-1, 0); break;\n        }\n    });\n\n    // Event listeners for buttons\n    startBtn.addEventListener('click', startGame);\n    pauseBtn.addEventListener('click', () => {\n        if (gamePaused) resumeGame();\n        else pauseGame();\n    });\n\n    setSizeBtn.addEventListener('click', () => {\n        const rowsValue = parseInt(rowsInput.value, 10);\n        const colsValue = parseInt(colsInput.value, 10);\n        if (rowsValue && colsValue) {\n            rows = rowsValue;\n            cols = colsValue;\n            canvas.width = cols * cellSize;\n            canvas.height = rows * cellSize;\n            timeRemaining = calculateTime();\n            resetGame();\n        }\n    });\n});",
      "status": "[1]<br><span style=\"font-size:8px\">2ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}